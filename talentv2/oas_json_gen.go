// Code generated by ogen, DO NOT EDIT.

package talentv2

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *ErrorResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error")
		e.Str(s.Error)
	}
}

var jsonFieldsNameOfErrorResponse = [1]string{
	0: "error",
}

// Decode decodes ErrorResponse from json.
func (s *ErrorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Error = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrorResponse) {
					name = jsonFieldsNameOfErrorResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Event) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Event) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int32(s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("draft")
		e.Bool(s.Draft)
	}
	{
		e.FieldStart("public")
		e.Bool(s.Public)
	}
	{
		e.FieldStart("hidden")
		e.Bool(s.Hidden)
	}
	{
		e.FieldStart("canceled")
		e.Bool(s.Canceled)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Format.Set {
			e.FieldStart("format")
			s.Format.Encode(e)
		}
	}
	{
		if s.OrganizationID.Set {
			e.FieldStart("organization_id")
			s.OrganizationID.Encode(e)
		}
	}
	{
		if s.MetaEventID.Set {
			e.FieldStart("meta_event_id")
			s.MetaEventID.Encode(e)
		}
	}
	{
		if s.CreatedByID.Set {
			e.FieldStart("created_by_id")
			s.CreatedByID.Encode(e)
		}
	}
	{
		if s.VenueID.Set {
			e.FieldStart("venue_id")
			s.VenueID.Encode(e)
		}
	}
	{
		e.FieldStart("achievements_allowed")
		e.Bool(s.AchievementsAllowed)
	}
	{
		e.FieldStart("requests_allowed")
		e.Bool(s.RequestsAllowed)
	}
	{
		e.FieldStart("simplified_registration")
		e.Bool(s.SimplifiedRegistration)
	}
	{
		e.FieldStart("self_check_in")
		e.Bool(s.SelfCheckIn)
	}
	{
		e.FieldStart("teams_involved")
		s.TeamsInvolved.Encode(e)
	}
	{
		e.FieldStart("owner_can_moderate")
		e.Bool(s.OwnerCanModerate)
	}
	{
		e.FieldStart("user_in_multiple_teams")
		e.Bool(s.UserInMultipleTeams)
	}
	{
		e.FieldStart("mentors_allowed")
		e.Bool(s.MentorsAllowed)
	}
	{
		e.FieldStart("support_i18n")
		e.Bool(s.SupportI18n)
	}
	{
		e.FieldStart("gir_collection")
		e.Bool(s.GirCollection)
	}
	{
		e.FieldStart("time_matters")
		e.Bool(s.TimeMatters)
	}
	{
		e.FieldStart("promoted")
		e.Bool(s.Promoted)
	}
	{
		if s.MaxUsers.Set {
			e.FieldStart("max_users")
			s.MaxUsers.Encode(e)
		}
	}
	{
		e.FieldStart("team_create_notification")
		e.Bool(s.TeamCreateNotification)
	}
	{
		if s.TeamAssignmentMethod.Set {
			e.FieldStart("team_assignment_method")
			s.TeamAssignmentMethod.Encode(e)
		}
	}
	{
		e.FieldStart("diplomas_dark_theme")
		e.Bool(s.DiplomasDarkTheme)
	}
	{
		if s.IsDiplomasIssued.Set {
			e.FieldStart("is_diplomas_issued")
			s.IsDiplomasIssued.Encode(e)
		}
	}
	{
		e.FieldStart("achievement_roles_count")
		e.Int32(s.AchievementRolesCount)
	}
	{
		e.FieldStart("achievements_count")
		e.Int32(s.AchievementsCount)
	}
	{
		e.FieldStart("requests_count")
		e.Int32(s.RequestsCount)
	}
	{
		if s.Cover.Set {
			e.FieldStart("cover")
			s.Cover.Encode(e)
		}
	}
	{
		if s.Background.Set {
			e.FieldStart("background")
			s.Background.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.TypeID.Set {
			e.FieldStart("type_id")
			s.TypeID.Encode(e)
		}
	}
	{
		if s.ExpectedStart.Set {
			e.FieldStart("expected_start")
			s.ExpectedStart.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.AltTitle.Set {
			e.FieldStart("alt_title")
			s.AltTitle.Encode(e)
		}
	}
	{
		if s.CancellationReason.Set {
			e.FieldStart("cancellation_reason")
			s.CancellationReason.Encode(e)
		}
	}
	{
		if s.QuestionnaireCompletedMessage.Set {
			e.FieldStart("questionnaire_completed_message")
			s.QuestionnaireCompletedMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfEvent = [44]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "draft",
	4:  "public",
	5:  "hidden",
	6:  "canceled",
	7:  "title",
	8:  "start",
	9:  "end",
	10: "format",
	11: "organization_id",
	12: "meta_event_id",
	13: "created_by_id",
	14: "venue_id",
	15: "achievements_allowed",
	16: "requests_allowed",
	17: "simplified_registration",
	18: "self_check_in",
	19: "teams_involved",
	20: "owner_can_moderate",
	21: "user_in_multiple_teams",
	22: "mentors_allowed",
	23: "support_i18n",
	24: "gir_collection",
	25: "time_matters",
	26: "promoted",
	27: "max_users",
	28: "team_create_notification",
	29: "team_assignment_method",
	30: "diplomas_dark_theme",
	31: "is_diplomas_issued",
	32: "achievement_roles_count",
	33: "achievements_count",
	34: "requests_count",
	35: "cover",
	36: "background",
	37: "url",
	38: "type_id",
	39: "expected_start",
	40: "description",
	41: "alt_title",
	42: "cancellation_reason",
	43: "questionnaire_completed_message",
}

// Decode decodes Event from json.
func (s *Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Event to nil")
	}
	var requiredBitSet [6]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "draft":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Draft = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		case "public":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Public = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		case "hidden":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Hidden = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "canceled":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Canceled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"canceled\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "format":
			if err := func() error {
				s.Format.Reset()
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "organization_id":
			if err := func() error {
				s.OrganizationID.Reset()
				if err := s.OrganizationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_id\"")
			}
		case "meta_event_id":
			if err := func() error {
				s.MetaEventID.Reset()
				if err := s.MetaEventID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta_event_id\"")
			}
		case "created_by_id":
			if err := func() error {
				s.CreatedByID.Reset()
				if err := s.CreatedByID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by_id\"")
			}
		case "venue_id":
			if err := func() error {
				s.VenueID.Reset()
				if err := s.VenueID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"venue_id\"")
			}
		case "achievements_allowed":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.AchievementsAllowed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_allowed\"")
			}
		case "requests_allowed":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.RequestsAllowed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_allowed\"")
			}
		case "simplified_registration":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.SimplifiedRegistration = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"simplified_registration\"")
			}
		case "self_check_in":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.SelfCheckIn = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self_check_in\"")
			}
		case "teams_involved":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TeamsInvolved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_involved\"")
			}
		case "owner_can_moderate":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.OwnerCanModerate = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner_can_moderate\"")
			}
		case "user_in_multiple_teams":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.UserInMultipleTeams = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_in_multiple_teams\"")
			}
		case "mentors_allowed":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.MentorsAllowed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mentors_allowed\"")
			}
		case "support_i18n":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.SupportI18n = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"support_i18n\"")
			}
		case "gir_collection":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.GirCollection = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gir_collection\"")
			}
		case "time_matters":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.TimeMatters = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_matters\"")
			}
		case "promoted":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Promoted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"promoted\"")
			}
		case "max_users":
			if err := func() error {
				s.MaxUsers.Reset()
				if err := s.MaxUsers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_users\"")
			}
		case "team_create_notification":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.TeamCreateNotification = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_create_notification\"")
			}
		case "team_assignment_method":
			if err := func() error {
				s.TeamAssignmentMethod.Reset()
				if err := s.TeamAssignmentMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_assignment_method\"")
			}
		case "diplomas_dark_theme":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.DiplomasDarkTheme = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diplomas_dark_theme\"")
			}
		case "is_diplomas_issued":
			if err := func() error {
				s.IsDiplomasIssued.Reset()
				if err := s.IsDiplomasIssued.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_diplomas_issued\"")
			}
		case "achievement_roles_count":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.AchievementRolesCount = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievement_roles_count\"")
			}
		case "achievements_count":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.AchievementsCount = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_count\"")
			}
		case "requests_count":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.RequestsCount = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_count\"")
			}
		case "cover":
			if err := func() error {
				s.Cover.Reset()
				if err := s.Cover.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cover\"")
			}
		case "background":
			if err := func() error {
				s.Background.Reset()
				if err := s.Background.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"background\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "type_id":
			if err := func() error {
				s.TypeID.Reset()
				if err := s.TypeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type_id\"")
			}
		case "expected_start":
			if err := func() error {
				s.ExpectedStart.Reset()
				if err := s.ExpectedStart.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expected_start\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "alt_title":
			if err := func() error {
				s.AltTitle.Reset()
				if err := s.AltTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alt_title\"")
			}
		case "cancellation_reason":
			if err := func() error {
				s.CancellationReason.Reset()
				if err := s.CancellationReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cancellation_reason\"")
			}
		case "questionnaire_completed_message":
			if err := func() error {
				s.QuestionnaireCompletedMessage.Reset()
				if err := s.QuestionnaireCompletedMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"questionnaire_completed_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Event")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [6]uint8{
		0b11111111,
		0b10000000,
		0b11111111,
		0b01010111,
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEvent) {
					name = jsonFieldsNameOfEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Event) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Event) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventFormat as json.
func (s EventFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventFormat from json.
func (s *EventFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventFormat(v) {
	case EventFormatOffline:
		*s = EventFormatOffline
	case EventFormatOnline:
		*s = EventFormatOnline
	default:
		*s = EventFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventIsDiplomasIssued as json.
func (s EventIsDiplomasIssued) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventIsDiplomasIssued from json.
func (s *EventIsDiplomasIssued) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventIsDiplomasIssued to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventIsDiplomasIssued(v) {
	case EventIsDiplomasIssuedAll:
		*s = EventIsDiplomasIssuedAll
	case EventIsDiplomasIssuedRoles:
		*s = EventIsDiplomasIssuedRoles
	default:
		*s = EventIsDiplomasIssued(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventIsDiplomasIssued) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventIsDiplomasIssued) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventMeta) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int32(s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("draft")
		e.Bool(s.Draft)
	}
	{
		e.FieldStart("public")
		e.Bool(s.Public)
	}
	{
		e.FieldStart("hidden")
		e.Bool(s.Hidden)
	}
	{
		e.FieldStart("canceled")
		e.Bool(s.Canceled)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Format.Set {
			e.FieldStart("format")
			s.Format.Encode(e)
		}
	}
	{
		if s.OrganizationID.Set {
			e.FieldStart("organization_id")
			s.OrganizationID.Encode(e)
		}
	}
	{
		if s.MetaEventID.Set {
			e.FieldStart("meta_event_id")
			s.MetaEventID.Encode(e)
		}
	}
	{
		if s.CreatedByID.Set {
			e.FieldStart("created_by_id")
			s.CreatedByID.Encode(e)
		}
	}
	{
		if s.VenueID.Set {
			e.FieldStart("venue_id")
			s.VenueID.Encode(e)
		}
	}
}

var jsonFieldsNameOfEventMeta = [15]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "draft",
	4:  "public",
	5:  "hidden",
	6:  "canceled",
	7:  "title",
	8:  "start",
	9:  "end",
	10: "format",
	11: "organization_id",
	12: "meta_event_id",
	13: "created_by_id",
	14: "venue_id",
}

// Decode decodes EventMeta from json.
func (s *EventMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventMeta to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "draft":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Draft = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		case "public":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Public = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		case "hidden":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Hidden = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "canceled":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Canceled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"canceled\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "format":
			if err := func() error {
				s.Format.Reset()
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "organization_id":
			if err := func() error {
				s.OrganizationID.Reset()
				if err := s.OrganizationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_id\"")
			}
		case "meta_event_id":
			if err := func() error {
				s.MetaEventID.Reset()
				if err := s.MetaEventID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta_event_id\"")
			}
		case "created_by_id":
			if err := func() error {
				s.CreatedByID.Reset()
				if err := s.CreatedByID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by_id\"")
			}
		case "venue_id":
			if err := func() error {
				s.VenueID.Reset()
				if err := s.VenueID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"venue_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventMeta")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventMeta) {
					name = jsonFieldsNameOfEventMeta[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventMetaFormat as json.
func (s EventMetaFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventMetaFormat from json.
func (s *EventMetaFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventMetaFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventMetaFormat(v) {
	case EventMetaFormatOffline:
		*s = EventMetaFormatOffline
	case EventMetaFormatOnline:
		*s = EventMetaFormatOnline
	default:
		*s = EventMetaFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventMetaFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventMetaFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventRetrieveOK as json.
func (s EventRetrieveOK) Encode(e *jx.Encoder) {
	switch s.Type {
	case EventMetaEventRetrieveOK:
		s.EventMeta.Encode(e)
	case EventEventRetrieveOK:
		s.Event.Encode(e)
	}
}

func (s EventRetrieveOK) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case EventMetaEventRetrieveOK:
		s.EventMeta.encodeFields(e)
	case EventEventRetrieveOK:
		s.Event.encodeFields(e)
	}
}

// Decode decodes EventRetrieveOK from json.
func (s *EventRetrieveOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventRetrieveOK to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "achievements_allowed":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "requests_allowed":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "simplified_registration":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "self_check_in":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "teams_involved":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "owner_can_moderate":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "user_in_multiple_teams":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "mentors_allowed":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "support_i18n":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "gir_collection":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "time_matters":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "promoted":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "max_users":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "team_create_notification":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "team_assignment_method":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "diplomas_dark_theme":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "is_diplomas_issued":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "achievement_roles_count":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "achievements_count":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "requests_count":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "cover":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "background":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "url":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "type_id":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "expected_start":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "description":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "alt_title":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "cancellation_reason":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "questionnaire_completed_message":
				match := EventEventRetrieveOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		s.Type = EventMetaEventRetrieveOK
	}
	switch s.Type {
	case EventMetaEventRetrieveOK:
		if err := s.EventMeta.Decode(d); err != nil {
			return err
		}
	case EventEventRetrieveOK:
		if err := s.Event.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventRetrieveOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventRetrieveOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventTeamAssignmentMethod as json.
func (s EventTeamAssignmentMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventTeamAssignmentMethod from json.
func (s *EventTeamAssignmentMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventTeamAssignmentMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventTeamAssignmentMethod(v) {
	case EventTeamAssignmentMethodCompletion:
		*s = EventTeamAssignmentMethodCompletion
	case EventTeamAssignmentMethodCompletionSoft:
		*s = EventTeamAssignmentMethodCompletionSoft
	case EventTeamAssignmentMethodSingle:
		*s = EventTeamAssignmentMethodSingle
	case EventTeamAssignmentMethodSingleSoft:
		*s = EventTeamAssignmentMethodSingleSoft
	default:
		*s = EventTeamAssignmentMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventTeamAssignmentMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventTeamAssignmentMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventTeamsInvolved as json.
func (s EventTeamsInvolved) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventTeamsInvolved from json.
func (s *EventTeamsInvolved) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventTeamsInvolved to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventTeamsInvolved(v) {
	case EventTeamsInvolvedAny:
		*s = EventTeamsInvolvedAny
	case EventTeamsInvolvedTeams:
		*s = EventTeamsInvolvedTeams
	case EventTeamsInvolvedIndividual:
		*s = EventTeamsInvolvedIndividual
	default:
		*s = EventTeamsInvolved(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventTeamsInvolved) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventTeamsInvolved) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes EventFormat as json.
func (o OptEventFormat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EventFormat from json.
func (o *OptEventFormat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEventFormat to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEventFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEventFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventIsDiplomasIssued as json.
func (o OptEventIsDiplomasIssued) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EventIsDiplomasIssued from json.
func (o *OptEventIsDiplomasIssued) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEventIsDiplomasIssued to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEventIsDiplomasIssued) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEventIsDiplomasIssued) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventMetaFormat as json.
func (o OptEventMetaFormat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EventMetaFormat from json.
func (o *OptEventMetaFormat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEventMetaFormat to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEventMetaFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEventMetaFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventTeamAssignmentMethod as json.
func (o OptEventTeamAssignmentMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EventTeamAssignmentMethod from json.
func (o *OptEventTeamAssignmentMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEventTeamAssignmentMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEventTeamAssignmentMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEventTeamAssignmentMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
